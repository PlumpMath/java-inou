/*
 *	fft.c
 *
 *	C Version 1.0 by Steve Sampson, Public Domain
 *
 *	This program is based on the work by W. D. Stanley
 *	and S. J. Peterson, Old Dominion University.
 *
 *	This program produces a Frequency Domain display
 *	from the Time Domain data input using the Fast Fourier Transform.
 *
 *	The REAL data is generated by the in-phase (I) channel and the
 *	IMAGINARY data is produced by the quadrature-phase (Q) channel of
 *	a Doppler Radar receiver.  The middle filter is zero Hz.  Closing
 *	targets are displayed to the right, and Opening targets to the left.
 *
 *	Note: With IMAGINARY data set to zero the output is a mirror image.
 *
 *	Usage:	fft  samples  input_data  output_data
 *	Where 'samples' is a power of two
 *
 *	Array Version for Turbo C 1.5
 */

/*  FFT Ver1.1
 *  This program is update by K.Mori(COW). Version 1.1 for Borland C++ 4.0 
 *  Usage: fft [option] samples sample_frequency input output
 *  option: /ri ...Real-Image input data(default)
 *          /ro ...Real Only input data
 *          /tr ...Time-Real input data(ignore Time)
 *  Where samples is a power of 2
 */

/*
 FFT on INOU
 This program was translated from C into Java 
 by M.Sakurai(m.sakurai@cmt.phys.kyushu-u.ac.jp)
 2001 Oct. 17
 */

package inou.math.fft;

import inou.math.Complex;

public class DFT_Cow extends DFTEngine {

    final static double TWO_PI = 2.0 * Math.PI;

    public final void dft_main(Complex[] ac, boolean flag) {
        int power;
        int i1, i2, i3, i4, y;
        int loop, loop1, loop2;
        double a1, a2, b1, b2, z1, z2, v;
        double sign = (!flag) ? 1. : -1.;

        power = (int) (Math.log(ac.length) / Math.log(2));
        System.out.println(power);

        // for (loop = 0; loop < ac.length; loop++) {
        // ac[loop].divs((double)ac.length);
        // }

        i1 = ac.length >> 1;
        i2 = 1;
        v = TWO_PI / ac.length;

        for (loop = 0; loop < power; loop++) {
            i3 = 0;
            i4 = i1;

            for (loop1 = 0; loop1 < i2; loop1++) {
                y = permute(i3 / i1, ac.length, power);
                z1 = Math.cos(v * y);
                z2 = -Math.sin(sign * v * y);

                for (loop2 = i3; loop2 < i4; loop2++) {
                    a1 = ac[loop2].r;
                    a2 = ac[loop2].i;

                    b1 = z1 * ac[loop2 + i1].r - z2 * ac[loop2 + i1].i;
                    b2 = z2 * ac[loop2 + i1].r + z1 * ac[loop2 + i1].i;

                    ac[loop2].r = a1 + b1;
                    ac[loop2].i = a2 + b2;

                    ac[loop2 + i1].r = a1 - b1;
                    ac[loop2 + i1].i = a2 - b2;
                }

                i3 += (i1 << 1);
                i4 += (i1 << 1);
            }

            i1 >>= 1;
            i2 <<= 1;
        }
    }

    /*
     * Bit reverse the number
     * 
     * Change 11100000b to 00000111b or vice-versa
     */

    int permute(int index, int arrayNum, int power) {
        int n1, result, loop;

        n1 = arrayNum;
        result = 0;

        for (loop = 0; loop < power; loop++) {
            n1 >>= 1; /* n1 / 2.0 */
            if (index < n1)
                continue;

            result += (int) Math.pow(2.0, loop);
            index -= n1;
        }

        return result;
    }
}
